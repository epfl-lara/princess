/**
 * This file is part of Princess, a theorem prover for Presburger
 * arithmetic with uninterpreted predicates.
 * <http://www.philipp.ruemmer.org/princess.shtml>
 *
 * Copyright (C) 2010,2011 Philipp Ruemmer <ph_r@gmx.net>
 *
 * Princess is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Princess is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Princess.  If not, see <http://www.gnu.org/licenses/>.
 */

package ap.parser

import ap.Signature
import ap.basetypes.IdealInt
import ap.terfor.preds.Predicate
import ap.terfor.{ConstantTerm, TermOrder}
import ap.terfor.conjunctions.Quantifier
import ap.util.Seqs

import java.io.PrintStream

/**
 * Class for printing <code>IFormula</code>s in the Princess format
 * 
 * Currently, functions are not handled in this class
 */
object PrincessLineariser {

  def apply(formula : IFormula, signature : Signature) = {
    val order = signature.order

    println("// Generated by Princess (http://www.philipp.ruemmer.org/princess.shtml) }")

    // declare the various kinds of constants
    for ((name, consts) <- List(("universalConstants", signature.universalConstants),
    		                    ("existentialConstants", signature.existentialConstants),
                                ("functions", signature.nullaryFunctions)))
      if (!consts.isEmpty) {
        println("\\" + name + " {")
        for (c <- consts)
          println("int " + c.name + ";")
        println("}")
      }
    
    // declare the required predicates
    if (!order.orderedPredicates.isEmpty) {
      println("\\predicates {")
      for (pred <- order.orderedPredicates) {
        print(pred.name)
        if (pred.arity > 0) {
          print("(")
          print((for (_ <- List.range(0, pred.arity)) yield "int") mkString ", ")
          print(")")
        }
        println(";")
      }
      println("}")
    }
    
    println("\\problem {")
    printExpression(formula)
    println
    println("}")
  }
  
  def printExpression(e : IExpression) =
    AbsyPrinter.visit(e, PrintContext(List(), ""))
  
  //////////////////////////////////////////////////////////////////////////////
  
  private case class PrintContext(vars : List[String], parentOp : String) {
    def pushVar(name : String) = PrintContext(name :: vars, parentOp)
    def setParentOp(op : String) = PrintContext(vars, op)
  }
  
  private object AbsyPrinter extends CollectingVisitor[PrintContext, Unit] {
    
    private def allButLast(ctxt : PrintContext, op : String, lastOp : String,
                           arity : Int) = {
      val newCtxt = ctxt setParentOp op
      SubArgs((for (_ <- 1 until arity) yield newCtxt) ++
                List(ctxt setParentOp lastOp))
    }
    
    private def noParentOp(ctxt : PrintContext) = UniSubArgs(ctxt setParentOp "")
    
    private def shortCut(ctxt : PrintContext) = {
      print(ctxt.parentOp)
      ShortCutResult(())
    }
    
    private object AtomicTerm {
      def unapply(t : IExpression) : Option[ITerm] = t match {
        case t : IConstant => Some(t)
        case t : IVariable => Some(t)
        case _ => None
      }
    }
    
    private def atomicTerm(t : ITerm,
                           ctxt : PrintContext) : String = t match {
      case IConstant(c)     => c.name
      case IVariable(index) => ctxt vars index
    }
    
    private def relation(rel : IIntRelation.Value) = rel match {
      case IIntRelation.EqZero => "="
      case IIntRelation.GeqZero => ">="
    }
    
    override def preVisit(t : IExpression,
                          ctxt : PrintContext) : PreVisitResult = t match {
      // Terms
      case IPlus(s, ITimes(IdealInt.MINUS_ONE, AtomicTerm(t))) => {
        TryAgain(s, ctxt setParentOp (" - " + atomicTerm(t, ctxt) + ctxt.parentOp))
      }
      case IPlus(s, ITimes(coeff, AtomicTerm(t))) if (coeff.signum < 0) => {
        TryAgain(s, ctxt setParentOp (" - " + coeff.abs + "*" + atomicTerm(t, ctxt) + ctxt.parentOp))
      }
      case IPlus(ITimes(IdealInt.MINUS_ONE, AtomicTerm(t)), s) => {
        TryAgain(s, ctxt setParentOp (" - " + atomicTerm(t, ctxt) + ctxt.parentOp))
      }
      case IPlus(ITimes(coeff, AtomicTerm(t)), s) if (coeff.signum < 0) => {
        TryAgain(s, ctxt setParentOp (" - " + coeff.abs + "*" + atomicTerm(t, ctxt) + ctxt.parentOp))
      }
      
      case AtomicTerm(t) => {
        print(atomicTerm(t, ctxt))
        noParentOp(ctxt)
      }
      case IIntLit(value) => {
        print(value)
        noParentOp(ctxt)
      }
      case IPlus(_, _) => {
        allButLast(ctxt, " + ", "", 2)
      }

      case ITimes(coeff, AtomicTerm(t)) => {
        print(coeff + "*" + atomicTerm(t, ctxt))
        shortCut(ctxt)
      }
      case ITimes(coeff, _) => {
        print(coeff + " * (")
        noParentOp(ctxt)
      }
      
      case IFunApp(fun, _) => {
        print(fun.name)
        print("(")
        allButLast(ctxt, ", ", ")", fun.arity)
      }

      // Formulae
      case IAtom(pred, _) => {
        print(pred.name)
        if (pred.arity > 0) {
          print("(")
          allButLast(ctxt, ", ", ")", pred.arity)
        } else {
          noParentOp(ctxt)
        }
      }
      case IBinFormula(junctor, _, _) => {
        print("(")
        allButLast(ctxt,
                   (junctor match {
                     case IBinJunctor.And => " & "
                     case IBinJunctor.Or => " | "
                     case IBinJunctor.Eqv => " <-> "
                    }), ")", 2)
      }
      case IBoolLit(value) => {
        print(value)
        noParentOp(ctxt)
      }
      
      case IIntFormula(rel, ITimes(IdealInt.MINUS_ONE, t)) => {
        print("(0 " + relation(rel) + " ")
        TryAgain(t, ctxt setParentOp (")" + ctxt.parentOp))
      }
      case IIntFormula(rel, IPlus(s, ITimes(IdealInt.MINUS_ONE, AtomicTerm(t)))) => {
        print("(")
        TryAgain(s, ctxt setParentOp (" " + relation(rel) + " " +
                                      atomicTerm(t, ctxt) + ")" + ctxt.parentOp))
      }
      case IIntFormula(rel, IPlus(s, ITimes(coeff, AtomicTerm(t)))) if (coeff.signum < 0) => {
        print("(")
        TryAgain(s, ctxt setParentOp (" " + relation(rel) + " " + coeff.abs + "*" +
                                      atomicTerm(t, ctxt) + ")" + ctxt.parentOp))
      }
      case IIntFormula(rel, IPlus(ITimes(IdealInt.MINUS_ONE, AtomicTerm(t)), s)) => {
        print("(")
        TryAgain(s, ctxt setParentOp (" " + relation(rel) + " " +
                                      atomicTerm(t, ctxt) + ")" + ctxt.parentOp))
      }
      case IIntFormula(rel, IPlus(ITimes(coeff, AtomicTerm(t)), s)) if (coeff.signum < 0) => {
        print("(")
        TryAgain(s, ctxt setParentOp (" " + relation(rel) + " " + coeff.abs + "*" +
                                      atomicTerm(t, ctxt) + ")" + ctxt.parentOp))
      }
      case IIntFormula(rel, IPlus(IIntLit(value), s)) => {
        print("(")
        TryAgain(s, ctxt setParentOp (" " + relation(rel) + " " + (-value) + ")" +
                                      ctxt.parentOp))
      }
      
      case IIntFormula(rel, _) => {
        print("(")
        UniSubArgs(ctxt setParentOp (" " + relation(rel) + " 0)"))
      }
      
      case INot(_) => {
        print("!")
        noParentOp(ctxt)
      }
      case IQuantified(quan, _) => {
        val varName = "var" + ctxt.vars.size
        print(quan match {
          case Quantifier.ALL => "\\forall"
          case Quantifier.EX => "\\exists"
        })
        print(" int " + varName + "; ")
        noParentOp(ctxt pushVar varName)
      }
      case INamedPart(name, _) => {
        if (name != PartName.NO_NAME)
          print("\\part[" + name + "] ")
        print("(")
        UniSubArgs(ctxt setParentOp ")")
      }
    }
    
    def postVisit(t : IExpression,
                  ctxt : PrintContext, subres : Seq[Unit]) : Unit =
      print(ctxt.parentOp)
  
  }
  
}
