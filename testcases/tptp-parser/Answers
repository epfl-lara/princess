Loading ARI496=1.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Preprocessing ...
Constructing countermodel ...

VALID

Loading ARI595=1.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Preprocessing ...
Proving ...

VALID

Loading ARI616=1.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Preprocessing ...
Proving ...

VALID

Loading ARI620=1.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Preprocessing ...
Proving ...

VALID

Loading ARI526=1.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Warning: Problem contains reals, using incomplete axiomatisation
Warning: Problem contains rationals, using incomplete axiomatisation
Preprocessing ...
Constructing countermodel ...

VALID

Loading ARI522=1.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Warning: Problem contains reals, using incomplete axiomatisation
Warning: Problem contains rationals, using incomplete axiomatisation
Preprocessing ...
Constructing countermodel ...

VALID

Loading GEG021=1.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Preprocessing ...
Proving ...

VALID

Loading PUZ001+1.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Preprocessing ...
Proving ...

VALID

Loading PUZ133=2.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Preprocessing ...
Proving ...

VALID

Loading SYN050-1.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Preprocessing ...
Proving ...

VALID

Loading SYO561_1.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Preprocessing ...
Constructing countermodel ...

VALID

Loading SYO563+1.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Preprocessing ...
Constructing countermodel ...

VALID

Loading SYO563+2.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Preprocessing ...
Constructing countermodel ...

VALID

Loading let-tests.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Warning: using theory to encode multiplication: GroebnerMultiplication
Preprocessing ...
Constructing countermodel ...

VALID

Loading quotes.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
green:\\'Color' = 0 & red:Color = 1

Loading multiple-conjectures.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Preprocessing ...
Constructing countermodel ...

VALID

Loading ARI120=1.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Warning: using theory to encode multiplication: GroebnerMultiplication
Preprocessing ...
Proving ...

VALID

Loading unsat-core.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Preprocessing ...
Warning: ignoring some quantifiers
Constructing countermodel ...
Found proof (size 84)

VALID

Unsatisfiable core:
{DIFF-row1-row2, DIFF-row1-row3, DIFF-row2-row3, DIFF-tempty-tcons, EQ-tcons, rawDifference-INV, rawDifference2, rawDifference4, rowIn-true-INV, rowIn0, rowIn1, test-4}

Loading unsat-core.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Preprocessing ...
Warning: ignoring some quantifiers
Constructing countermodel ...
Found proof (size 84)

VALID

% SZS output start Proof for theBenchmark
Assumptions after simplification:
---------------------------------

  (DIFF-row1-row2)
   ~ (vrow1 = vrow2)

  (DIFF-row1-row3)
   ~ (vrow3 = vrow1)

  (DIFF-row2-row3)
   ~ (vrow3 = vrow2)

  (DIFF-tempty-tcons)
   ! [v0: $int] :  ! [v1: $int] :  ~ (vtcons(v0, v1) = vtempty)

  (EQ-tcons)
   ! [v0: $int] :  ! [v1: $int] :  ! [v2: $int] :  ! [v3: $int] :  ! [v4: $int]
  : ( ~ (vtcons(v1, v3) = v4) |  ~ (vtcons(v0, v2) = v4) | (v3 = v2 & v1 = v0))
  &  ! [v0: $int] :  ! [v1: $int] :  ! [v2: $int] :  ! [v3: $int] : (v3 = v2 | 
    ~ (vtcons(v0, v1) = v3) |  ~ (vtcons(v0, v1) = v2))

  (rawDifference-INV)
   ! [v0: $int] :  ! [v1: $int] :  ! [v2: $int] : ( ~ (vrawDifference(v0, v1) =
      v2) |  ? [v3: $int] :  ? [v4: $int] :  ? [v5: $int] : ( ~ (v4 = vtempty) &
      vrawDifference(v4, v1) = v3 & vrowIn(v5, v1) = 1 & vtcons(v5, v4) = v0 &
      vtcons(v5, v3) = v2) |  ? [v3: $int] :  ? [v4: $int] : ( ~ (v3 = vtempty)
      & vrawDifference(v3, v1) = v2 & vrowIn(v4, v1) = 0 & vtcons(v4, v3) = v0)
    |  ? [v3: $int] : (v2 = v0 & vrowIn(v3, v1) = 1 & vtcons(v3, vtempty) = v0)
    |  ? [v3: $int] : (v2 = vtempty & vrowIn(v3, v1) = 0 & vtcons(v3, vtempty) =
      v0) | (v2 = v0 & v1 = vtempty) | (v2 = vtempty & v0 = vtempty))

  (rawDifference2)
   ! [v0: $int] :  ! [v1: $int] :  ! [v2: $int] :  ! [v3: $int] : (v3 = v2 |  ~
    (vrawDifference(v2, v1) = v3) |  ~ (vtcons(v0, vtempty) = v2) | vrowIn(v0,
      v1) = 0)

  (rawDifference4)
   ! [v0: $int] :  ! [v1: $int] :  ! [v2: $int] :  ! [v3: $int] :  ! [v4: $int]
  :  ! [v5: $int] :  ! [v6: $int] : (v6 = v5 | v1 = vtempty |  ~
    (vrawDifference(v4, v2) = v5) |  ~ (vtcons(v3, v1) = v4) |  ~ (vtcons(v3,
        v0) = v6) |  ? [v7: $int] :  ? [v8: $int] : ((v8 = 0 & vrowIn(v3, v2) =
        0) | ( ~ (v7 = v0) & vrawDifference(v1, v2) = v7)))

  (rowIn-true-INV)
   ! [v0: $int] :  ! [v1: $int] : ( ~ (vrowIn(v0, v1) = 0) |  ? [v2: $int] :  ?
    [v3: $int] :  ? [v4: $int] : (vtcons(v2, v3) = v1 & (v2 = v0 | (v4 = 0 &
          vrowIn(v0, v3) = 0))))

  (rowIn0)
   ! [v0: $int] :  ~ (vrowIn(v0, vtempty) = 0)

  (rowIn1)
   ! [v0: $int] :  ! [v1: $int] :  ! [v2: $int] :  ! [v3: $int] :  ! [v4: $int]
  : (v4 = 0 |  ~ (vrowIn(v0, v3) = v4) |  ~ (vtcons(v1, v2) = v3) | ( ~ (v1 =
        v0) & vrowIn(v0, v2) = 1)) &  ! [v0: $int] :  ! [v1: $int] :  ! [v2:
    $int] :  ! [v3: $int] : (v1 = v0 |  ~ (vrowIn(v0, v3) = 0) |  ~ (vtcons(v1,
        v2) = v3) | vrowIn(v0, v2) = 0)

  (test-4)
   ? [v0: $int] :  ? [v1: $int] :  ? [v2: $int] :  ? [v3: $int] : (vtcons(vrow3,
      v2) = v3 & vtcons(vrow1, v0) = v1 & vtcons(vrow1, vtempty) = v2 &
    vtcons(vrow2, vtempty) = v0 &  ? [v4: $int] : ( ~ (v4 = v0) &
      vrawDifference(v1, v3) = v4))

Further assumptions not needed in the proof:
--------------------------------------------
DIFF-Intersection-Difference, DIFF-SelectAllFrom-Difference,
DIFF-SelectAllFrom-Intersection, DIFF-SelectAllFrom-SelectAllFromWhere,
DIFF-SelectAllFrom-SelectSomeFrom, DIFF-SelectAllFrom-SelectSomeFromWhere,
DIFF-SelectAllFrom-Union, DIFF-SelectAllFromWhere-Difference,
DIFF-SelectAllFromWhere-Intersection,
DIFF-SelectAllFromWhere-SelectSomeFromWhere, DIFF-SelectAllFromWhere-Union,
DIFF-SelectSomeFrom-Difference, DIFF-SelectSomeFrom-Intersection,
DIFF-SelectSomeFrom-SelectAllFromWhere, DIFF-SelectSomeFrom-SelectSomeFromWhere,
DIFF-SelectSomeFrom-Union, DIFF-SelectSomeFromWhere-Difference,
DIFF-SelectSomeFromWhere-Intersection, DIFF-SelectSomeFromWhere-Union,
DIFF-Tvalue-Difference, DIFF-Tvalue-Intersection, DIFF-Tvalue-SelectAllFrom,
DIFF-Tvalue-SelectAllFromWhere, DIFF-Tvalue-SelectSomeFrom,
DIFF-Tvalue-SelectSomeFromWhere, DIFF-Tvalue-Union, DIFF-Union-Difference,
DIFF-Union-Intersection, DIFF-VEquals-VGreater, DIFF-VEquals-VSmaller,
DIFF-VGreater-VSmaller, DIFF-aempty-acons, DIFF-emptyContext-bindContext,
DIFF-emptyStore-bindStore, DIFF-error-isFalse, DIFF-error-isTrue,
DIFF-isTrue-isFalse, DIFF-noConf-someConf, DIFF-noFType-someFType,
DIFF-noRawTable-someRawTable, DIFF-noTType-someTType, DIFF-noTable-someTable,
DIFF-rempty-rcons, DIFF-rtempty-rtcons, DIFF-ttempty-ttcons, EQ-Difference,
EQ-Intersection, EQ-Ref, EQ-SelectAllFrom, EQ-SelectAllFromWhere,
EQ-SelectSomeFrom, EQ-SelectSomeFromWhere, EQ-Tvalue, EQ-Union, EQ-VEquals,
EQ-VGreater, EQ-VSmaller, EQ-acons, EQ-bindContext, EQ-bindStore, EQ-conf,
EQ-ctype, EQ-rcons, EQ-rtcons, EQ-someConf, EQ-someFType, EQ-someRawTable,
EQ-someTType, EQ-someTable, EQ-table, EQ-ttcons, StoreContext-Lookup-WT,
StoreContextConsistent-false-INV, StoreContextConsistent-true-INV,
StoreContextConsistent0, StoreContextConsistent1, StoreContextConsistent2,
T-Difference, T-Intersection, T-SelectAllFrom, T-SelectAllFromWhere,
T-SelectSomeFrom, T-SelectSomeFromWhere, T-TTContext-Duplicate,
T-TTContext-Swap, T-Tvalue, T-Union, append-INV, append0, append1,
attachColToFrontRaw-INV, attachColToFrontRaw0, attachColToFrontRaw1,
attachColToFrontRaw2, attachColToFrontRaw3, checkPValidity-false-INV,
checkPValidity-true-INV, checkPValidity0, checkPValidity1, checkPValidity2,
ctypeIn-false-INV, ctypeIn-true-INV, ctypeIn0, ctypeIn1, difference-INV,
difference0, difference1, dropFirstColRaw-INV, dropFirstColRaw0,
dropFirstColRaw1, dropFirstColRaw2, findCol-INV, findCol0, findCol1, findCol2,
findColType0, findColType1, findColType2, getAL0, getQuery0, getRaw0,
getSomeConf0, getSomeFType0, getSomeRawTable0, getSomeTType0, getSomeTable0,
intersect-INV, intersect0, intersect1, isSomeConf-false-INV,
isSomeConf-true-INV, isSomeConf0, isSomeConf1, isSomeFType-false-INV,
isSomeFType-true-INV, isSomeFType0, isSomeFType1, isSomeRawTable-false-INV,
isSomeRawTable-true-INV, isSomeRawTable0, isSomeRawTable1,
isSomeTType-false-INV, isSomeTType-true-INV, isSomeTType0, isSomeTType1,
isSomeTable-false-INV, isSomeTable-true-INV, isSomeTable0, isSomeTable1,
isValue-false-INV, isValue-true-INV, isValue0, isValue1, isValue2, isValue3,
isValue4, isValue5, isValue6, isValue7, lookupContext-INV, lookupContext0,
lookupContext1, lookupContext2, lookupStore-INV, lookupStore0, lookupStore1,
lookupStore2, matchingAList-false-INV, matchingAList-true-INV, matchingAList0,
matchingAList1, matchingAList2, project-INV, project0, project1, project2,
projectEmptyCol0, projectEmptyCol1, projectFirstRaw0, projectFirstRaw1,
projectFirstRaw2, projectType0, projectType1, projectType2, rawDifference0,
rawDifference1, rawDifference3, rawDifference5, rawIntersection-INV,
rawIntersection0, rawIntersection1, rawIntersection2, rawIntersection3,
rawIntersection4, rawIntersection5, rawType-INV, rawType0, rawType1,
rawUnion-INV, rawUnion0, rawUnion1, rawUnion2, rawUnion3, reduce-INV, reduce0,
reduce1, reduce10, reduce11, reduce12, reduce13, reduce14, reduce15, reduce16,
reduce17, reduce18, reduce19, reduce2, reduce20, reduce21, reduce22, reduce23,
reduce24, reduce25, reduce26, reduce27, reduce28, reduce29, reduce3, reduce30,
reduce4, reduce5, reduce6, reduce7, reduce8, reduce9, rowIn-false-INV,
select-INV, select0, select1, select2, select3, singleRowSelect-INV,
singleRowSelect0, singleRowSelect1, singleRowSelect10, singleRowSelect11,
singleRowSelect12, singleRowSelect13, singleRowSelect14, singleRowSelect15,
singleRowSelect16, singleRowSelect17, singleRowSelect2, singleRowSelect3,
singleRowSelect4, singleRowSelect5, singleRowSelect6, singleRowSelect7,
singleRowSelect8, singleRowSelect9, union-INV, union0, union1,
welltypedRawtable-false-INV, welltypedRawtable-true-INV, welltypedRawtable0,
welltypedRawtable1, welltypedRow-false-INV, welltypedRow-true-INV,
welltypedRow0, welltypedRow1, welltypedRow2, welltypedtable-false-INV,
welltypedtable-true-INV, welltypedtable0

Those formulas are unsatisfiable:
---------------------------------

Begin of proof
| 
| ALPHA: (EQ-tcons) implies:
|   (1)   ! [v0: $int] :  ! [v1: $int] :  ! [v2: $int] :  ! [v3: $int] :  ! [v4:
|          $int] : ( ~ (vtcons(v1, v3) = v4) |  ~ (vtcons(v0, v2) = v4) | (v3 =
|            v2 & v1 = v0))
| 
| ALPHA: (rowIn1) implies:
|   (2)   ! [v0: $int] :  ! [v1: $int] :  ! [v2: $int] :  ! [v3: $int] : (v1 =
|          v0 |  ~ (vrowIn(v0, v3) = 0) |  ~ (vtcons(v1, v2) = v3) | vrowIn(v0,
|            v2) = 0)
|   (3)   ! [v0: $int] :  ! [v1: $int] :  ! [v2: $int] :  ! [v3: $int] :  ! [v4:
|          $int] : (v4 = 0 |  ~ (vrowIn(v0, v3) = v4) |  ~ (vtcons(v1, v2) = v3)
|          | ( ~ (v1 = v0) & vrowIn(v0, v2) = 1))
| 
| DELTA: instantiating (test-4) with fresh symbols all_279_0, all_279_1,
|        all_279_2, all_279_3 gives:
|   (4)  vtcons(vrow3, all_279_1) = all_279_0 & vtcons(vrow1, all_279_3) =
|        all_279_2 & vtcons(vrow1, vtempty) = all_279_1 & vtcons(vrow2, vtempty)
|        = all_279_3 &  ? [v0: $int] : ( ~ (v0 = all_279_3) &
|          vrawDifference(all_279_2, all_279_0) = v0)
| 
| ALPHA: (4) implies:
|   (5)  vtcons(vrow2, vtempty) = all_279_3
|   (6)  vtcons(vrow1, vtempty) = all_279_1
|   (7)  vtcons(vrow1, all_279_3) = all_279_2
|   (8)  vtcons(vrow3, all_279_1) = all_279_0
|   (9)   ? [v0: $int] : ( ~ (v0 = all_279_3) & vrawDifference(all_279_2,
|            all_279_0) = v0)
| 
| DELTA: instantiating (9) with fresh symbol all_447_0 gives:
|   (10)   ~ (all_447_0 = all_279_3) & vrawDifference(all_279_2, all_279_0) =
|         all_447_0
| 
| ALPHA: (10) implies:
|   (11)   ~ (all_447_0 = all_279_3)
|   (12)  vrawDifference(all_279_2, all_279_0) = all_447_0
| 
| GROUND_INST: instantiating (rawDifference-INV) with all_447_0, all_279_0,
|              all_279_2, simplifying with (12) gives:
|   (13)   ? [v0: $int] :  ? [v1: $int] :  ? [v2: $int] : ( ~ (v1 = vtempty) &
|           vrawDifference(v1, all_279_0) = v0 & vrowIn(v2, all_279_0) = 1 &
|           vtcons(v2, v1) = all_279_2 & vtcons(v2, v0) = all_447_0) |  ? [v0:
|           $int] :  ? [v1: $int] : ( ~ (v0 = vtempty) & vrawDifference(v0,
|             all_279_0) = all_447_0 & vrowIn(v1, all_279_0) = 0 & vtcons(v1,
|             v0) = all_279_2) |  ? [v0: $int] : (all_447_0 = all_279_2 &
|           vrowIn(v0, all_279_0) = 1 & vtcons(v0, vtempty) = all_279_2) |  ?
|         [v0: $int] : (all_447_0 = vtempty & vrowIn(v0, all_279_0) = 0 &
|           vtcons(v0, vtempty) = all_279_2) | (all_447_0 = all_279_2 &
|           all_279_0 = vtempty) | (all_447_0 = vtempty & all_279_2 = vtempty)
| 
| GROUND_INST: instantiating (rawDifference4) with all_279_2, all_447_0,
|              all_279_2, vrow1, all_279_0, all_279_3, all_279_3, simplifying
|              with (7), (12) gives:
|   (14)  all_447_0 = all_279_2 | all_279_3 = vtempty |  ? [v0: $int] :  ? [v1:
|           $int] : ((v1 = 0 & vrowIn(vrow1, all_279_0) = 0) | ( ~ (v0 =
|               all_279_3) & vrawDifference(all_279_3, all_279_0) = v0))
| 
| BETA: splitting (14) gives:
| 
| Case 1:
| | 
| |   (15)  all_279_3 = vtempty
| | 
| | REDUCE: (5), (15) imply:
| |   (16)  vtcons(vrow2, vtempty) = vtempty
| | 
| | GROUND_INST: instantiating (DIFF-tempty-tcons) with vtempty, vrow2,
| |              simplifying with (16) gives:
| |   (17)  $false
| | 
| | CLOSE: (17) is inconsistent.
| | 
| Case 2:
| | 
| |   (18)   ~ (all_279_3 = vtempty)
| | 
| | BETA: splitting (13) gives:
| | 
| | Case 1:
| | | 
| | |   (19)   ? [v0: $int] :  ? [v1: $int] :  ? [v2: $int] : ( ~ (v1 = vtempty)
| | |           & vrawDifference(v1, all_279_0) = v0 & vrowIn(v2, all_279_0) = 1
| | |           & vtcons(v2, v1) = all_279_2 & vtcons(v2, v0) = all_447_0) |  ?
| | |         [v0: $int] :  ? [v1: $int] : ( ~ (v0 = vtempty) &
| | |           vrawDifference(v0, all_279_0) = all_447_0 & vrowIn(v1,
| | |             all_279_0) = 0 & vtcons(v1, v0) = all_279_2) |  ? [v0: $int] :
| | |         (all_447_0 = all_279_2 & vrowIn(v0, all_279_0) = 1 & vtcons(v0,
| | |             vtempty) = all_279_2) |  ? [v0: $int] : (all_447_0 = vtempty &
| | |           vrowIn(v0, all_279_0) = 0 & vtcons(v0, vtempty) = all_279_2) |
| | |         (all_447_0 = all_279_2 & all_279_0 = vtempty)
| | | 
| | | BETA: splitting (19) gives:
| | | 
| | | Case 1:
| | | | 
| | | |   (20)   ? [v0: $int] :  ? [v1: $int] :  ? [v2: $int] : ( ~ (v1 =
| | | |             vtempty) & vrawDifference(v1, all_279_0) = v0 & vrowIn(v2,
| | | |             all_279_0) = 1 & vtcons(v2, v1) = all_279_2 & vtcons(v2, v0)
| | | |           = all_447_0) |  ? [v0: $int] :  ? [v1: $int] : ( ~ (v0 =
| | | |             vtempty) & vrawDifference(v0, all_279_0) = all_447_0 &
| | | |           vrowIn(v1, all_279_0) = 0 & vtcons(v1, v0) = all_279_2) |  ?
| | | |         [v0: $int] : (all_447_0 = all_279_2 & vrowIn(v0, all_279_0) = 1
| | | |           & vtcons(v0, vtempty) = all_279_2) |  ? [v0: $int] :
| | | |         (all_447_0 = vtempty & vrowIn(v0, all_279_0) = 0 & vtcons(v0,
| | | |             vtempty) = all_279_2)
| | | | 
| | | | BETA: splitting (20) gives:
| | | | 
| | | | Case 1:
| | | | | 
| | | | |   (21)   ? [v0: $int] :  ? [v1: $int] :  ? [v2: $int] : ( ~ (v1 =
| | | | |             vtempty) & vrawDifference(v1, all_279_0) = v0 & vrowIn(v2,
| | | | |             all_279_0) = 1 & vtcons(v2, v1) = all_279_2 & vtcons(v2,
| | | | |             v0) = all_447_0) |  ? [v0: $int] :  ? [v1: $int] : ( ~ (v0
| | | | |             = vtempty) & vrawDifference(v0, all_279_0) = all_447_0 &
| | | | |           vrowIn(v1, all_279_0) = 0 & vtcons(v1, v0) = all_279_2) |  ?
| | | | |         [v0: $int] : (all_447_0 = all_279_2 & vrowIn(v0, all_279_0) =
| | | | |           1 & vtcons(v0, vtempty) = all_279_2)
| | | | | 
| | | | | BETA: splitting (21) gives:
| | | | | 
| | | | | Case 1:
| | | | | | 
| | | | | |   (22)   ? [v0: $int] :  ? [v1: $int] :  ? [v2: $int] : ( ~ (v1 =
| | | | | |             vtempty) & vrawDifference(v1, all_279_0) = v0 &
| | | | | |           vrowIn(v2, all_279_0) = 1 & vtcons(v2, v1) = all_279_2 &
| | | | | |           vtcons(v2, v0) = all_447_0) |  ? [v0: $int] :  ? [v1:
| | | | | |           $int] : ( ~ (v0 = vtempty) & vrawDifference(v0, all_279_0)
| | | | | |           = all_447_0 & vrowIn(v1, all_279_0) = 0 & vtcons(v1, v0) =
| | | | | |           all_279_2)
| | | | | | 
| | | | | | BETA: splitting (22) gives:
| | | | | | 
| | | | | | Case 1:
| | | | | | | 
| | | | | | |   (23)   ? [v0: $int] :  ? [v1: $int] :  ? [v2: $int] : ( ~ (v1 =
| | | | | | |             vtempty) & vrawDifference(v1, all_279_0) = v0 &
| | | | | | |           vrowIn(v2, all_279_0) = 1 & vtcons(v2, v1) = all_279_2 &
| | | | | | |           vtcons(v2, v0) = all_447_0)
| | | | | | | 
| | | | | | | DELTA: instantiating (23) with fresh symbols all_731_0, all_731_1,
| | | | | | |        all_731_2 gives:
| | | | | | |   (24)   ~ (all_731_1 = vtempty) & vrawDifference(all_731_1,
| | | | | | |           all_279_0) = all_731_2 & vrowIn(all_731_0, all_279_0) =
| | | | | | |         1 & vtcons(all_731_0, all_731_1) = all_279_2 &
| | | | | | |         vtcons(all_731_0, all_731_2) = all_447_0
| | | | | | | 
| | | | | | | ALPHA: (24) implies:
| | | | | | |   (25)  vtcons(all_731_0, all_731_1) = all_279_2
| | | | | | |   (26)  vrowIn(all_731_0, all_279_0) = 1
| | | | | | | 
| | | | | | | GROUND_INST: instantiating (1) with all_279_2, all_731_1,
| | | | | | |              all_279_3, all_731_0, vrow1, simplifying with (7),
| | | | | | |              (25) gives:
| | | | | | |   (27)  all_731_0 = vrow1 & all_731_1 = all_279_3
| | | | | | | 
| | | | | | | ALPHA: (27) implies:
| | | | | | |   (28)  all_731_0 = vrow1
| | | | | | | 
| | | | | | | REDUCE: (26), (28) imply:
| | | | | | |   (29)  vrowIn(vrow1, all_279_0) = 1
| | | | | | | 
| | | | | | | GROUND_INST: instantiating (3) with 1, all_279_0, all_279_1,
| | | | | | |              vrow3, vrow1, simplifying with (8), (29) gives:
| | | | | | |   (30)   ~ (vrow3 = vrow1) & vrowIn(vrow1, all_279_1) = 1
| | | | | | | 
| | | | | | | ALPHA: (30) implies:
| | | | | | |   (31)  vrowIn(vrow1, all_279_1) = 1
| | | | | | | 
| | | | | | | GROUND_INST: instantiating (3) with 1, all_279_1, vtempty, vrow1,
| | | | | | |              vrow1, simplifying with (6), (31) gives:
| | | | | | |   (32)  $false
| | | | | | | 
| | | | | | | CLOSE: (32) is inconsistent.
| | | | | | | 
| | | | | | Case 2:
| | | | | | | 
| | | | | | |   (33)   ? [v0: $int] :  ? [v1: $int] : ( ~ (v0 = vtempty) &
| | | | | | |           vrawDifference(v0, all_279_0) = all_447_0 & vrowIn(v1,
| | | | | | |             all_279_0) = 0 & vtcons(v1, v0) = all_279_2)
| | | | | | | 
| | | | | | | DELTA: instantiating (33) with fresh symbols all_731_0, all_731_1
| | | | | | |        gives:
| | | | | | |   (34)   ~ (all_731_1 = vtempty) & vrawDifference(all_731_1,
| | | | | | |           all_279_0) = all_447_0 & vrowIn(all_731_0, all_279_0) =
| | | | | | |         0 & vtcons(all_731_0, all_731_1) = all_279_2
| | | | | | | 
| | | | | | | ALPHA: (34) implies:
| | | | | | |   (35)  vtcons(all_731_0, all_731_1) = all_279_2
| | | | | | |   (36)  vrowIn(all_731_0, all_279_0) = 0
| | | | | | |   (37)  vrawDifference(all_731_1, all_279_0) = all_447_0
| | | | | | | 
| | | | | | | GROUND_INST: instantiating (1) with all_279_2, all_731_1,
| | | | | | |              all_279_3, all_731_0, vrow1, simplifying with (7),
| | | | | | |              (35) gives:
| | | | | | |   (38)  all_731_0 = vrow1 & all_731_1 = all_279_3
| | | | | | | 
| | | | | | | ALPHA: (38) implies:
| | | | | | |   (39)  all_731_1 = all_279_3
| | | | | | |   (40)  all_731_0 = vrow1
| | | | | | | 
| | | | | | | REDUCE: (37), (39) imply:
| | | | | | |   (41)  vrawDifference(all_279_3, all_279_0) = all_447_0
| | | | | | | 
| | | | | | | REDUCE: (36), (40) imply:
| | | | | | |   (42)  vrowIn(vrow1, all_279_0) = 0
| | | | | | | 
| | | | | | | GROUND_INST: instantiating (rawDifference2) with all_447_0,
| | | | | | |              all_279_3, all_279_0, vrow2, simplifying with (5),
| | | | | | |              (41) gives:
| | | | | | |   (43)  all_447_0 = all_279_3 | vrowIn(vrow2, all_279_0) = 0
| | | | | | | 
| | | | | | | GROUND_INST: instantiating (2) with all_279_0, all_279_1, vrow3,
| | | | | | |              vrow1, simplifying with (8), (42) gives:
| | | | | | |   (44)  vrow3 = vrow1 | vrowIn(vrow1, all_279_1) = 0
| | | | | | | 
| | | | | | | BETA: splitting (44) gives:
| | | | | | | 
| | | | | | | Case 1:
| | | | | | | | 
| | | | | | | |   (45)  vrowIn(vrow1, all_279_1) = 0
| | | | | | | | 
| | | | | | | | BETA: splitting (43) gives:
| | | | | | | | 
| | | | | | | | Case 1:
| | | | | | | | | 
| | | | | | | | |   (46)  vrowIn(vrow2, all_279_0) = 0
| | | | | | | | | 
| | | | | | | | | GROUND_INST: instantiating (rowIn-true-INV) with all_279_1,
| | | | | | | | |              vrow1, simplifying with (45) gives:
| | | | | | | | |   (47)   ? [v0: $int] :  ? [v1: $int] :  ? [v2: $int] :
| | | | | | | | |         (vtcons(v0, v1) = all_279_1 & (v0 = vrow1 | (v2 = 0 &
| | | | | | | | |               vrowIn(vrow1, v1) = 0)))
| | | | | | | | | 
| | | | | | | | | GROUND_INST: instantiating (2) with all_279_0, all_279_1,
| | | | | | | | |              vrow3, vrow2, simplifying with (8), (46) gives:
| | | | | | | | |   (48)  vrow3 = vrow2 | vrowIn(vrow2, all_279_1) = 0
| | | | | | | | | 
| | | | | | | | | DELTA: instantiating (47) with fresh symbols all_831_0,
| | | | | | | | |        all_831_1, all_831_2 gives:
| | | | | | | | |   (49)  vtcons(all_831_2, all_831_1) = all_279_1 & (all_831_2
| | | | | | | | |           = vrow1 | (all_831_0 = 0 & vrowIn(vrow1, all_831_1)
| | | | | | | | |             = 0))
| | | | | | | | | 
| | | | | | | | | ALPHA: (49) implies:
| | | | | | | | |   (50)  vtcons(all_831_2, all_831_1) = all_279_1
| | | | | | | | | 
| | | | | | | | | BETA: splitting (48) gives:
| | | | | | | | | 
| | | | | | | | | Case 1:
| | | | | | | | | | 
| | | | | | | | | |   (51)  vrowIn(vrow2, all_279_1) = 0
| | | | | | | | | | 
| | | | | | | | | | GROUND_INST: instantiating (1) with all_279_1, all_831_1,
| | | | | | | | | |              vtempty, all_831_2, vrow1, simplifying with (6),
| | | | | | | | | |              (50) gives:
| | | | | | | | | |   (52)  all_831_1 = vtempty & all_831_2 = vrow1
| | | | | | | | | | 
| | | | | | | | | | ALPHA: (52) implies:
| | | | | | | | | |   (53)  all_831_2 = vrow1
| | | | | | | | | |   (54)  all_831_1 = vtempty
| | | | | | | | | | 
| | | | | | | | | | GROUND_INST: instantiating (2) with all_279_1, vtempty, vrow1,
| | | | | | | | | |              vrow2, simplifying with (6), (51) gives:
| | | | | | | | | |   (55)  vrow1 = vrow2 | vrowIn(vrow2, vtempty) = 0
| | | | | | | | | | 
| | | | | | | | | | BETA: splitting (55) gives:
| | | | | | | | | | 
| | | | | | | | | | Case 1:
| | | | | | | | | | | 
| | | | | | | | | | |   (56)  vrowIn(vrow2, vtempty) = 0
| | | | | | | | | | | 
| | | | | | | | | | | GROUND_INST: instantiating (rowIn0) with vrow2, simplifying
| | | | | | | | | | |              with (56) gives:
| | | | | | | | | | |   (57)  $false
| | | | | | | | | | | 
| | | | | | | | | | | CLOSE: (57) is inconsistent.
| | | | | | | | | | | 
| | | | | | | | | | Case 2:
| | | | | | | | | | | 
| | | | | | | | | | |   (58)  vrow1 = vrow2
| | | | | | | | | | | 
| | | | | | | | | | | REDUCE: (58), (DIFF-row1-row2) imply:
| | | | | | | | | | |   (59)   ~ (0 = 0)
| | | | | | | | | | | 
| | | | | | | | | | | CLOSE: (59) is inconsistent.
| | | | | | | | | | | 
| | | | | | | | | | End of split
| | | | | | | | | | 
| | | | | | | | | Case 2:
| | | | | | | | | | 
| | | | | | | | | |   (60)  vrow3 = vrow2
| | | | | | | | | | 
| | | | | | | | | | REDUCE: (60), (DIFF-row2-row3) imply:
| | | | | | | | | |   (61)   ~ (0 = 0)
| | | | | | | | | | 
| | | | | | | | | | CLOSE: (61) is inconsistent.
| | | | | | | | | | 
| | | | | | | | | End of split
| | | | | | | | | 
| | | | | | | | Case 2:
| | | | | | | | | 
| | | | | | | | |   (62)  all_447_0 = all_279_3
| | | | | | | | | 
| | | | | | | | | REDUCE: (11), (62) imply:
| | | | | | | | |   (63)   ~ (0 = 0)
| | | | | | | | | 
| | | | | | | | | CLOSE: (63) is inconsistent.
| | | | | | | | | 
| | | | | | | | End of split
| | | | | | | | 
| | | | | | | Case 2:
| | | | | | | | 
| | | | | | | |   (64)  vrow3 = vrow1
| | | | | | | | 
| | | | | | | | REDUCE: (64), (DIFF-row1-row3) imply:
| | | | | | | |   (65)   ~ (0 = 0)
| | | | | | | | 
| | | | | | | | CLOSE: (65) is inconsistent.
| | | | | | | | 
| | | | | | | End of split
| | | | | | | 
| | | | | | End of split
| | | | | | 
| | | | | Case 2:
| | | | | | 
| | | | | |   (66)   ? [v0: $int] : (all_447_0 = all_279_2 & vrowIn(v0,
| | | | | |             all_279_0) = 1 & vtcons(v0, vtempty) = all_279_2)
| | | | | | 
| | | | | | DELTA: instantiating (66) with fresh symbol all_731_0 gives:
| | | | | |   (67)  all_447_0 = all_279_2 & vrowIn(all_731_0, all_279_0) = 1 &
| | | | | |         vtcons(all_731_0, vtempty) = all_279_2
| | | | | | 
| | | | | | ALPHA: (67) implies:
| | | | | |   (68)  vtcons(all_731_0, vtempty) = all_279_2
| | | | | | 
| | | | | | GROUND_INST: instantiating (1) with all_279_2, vtempty, all_279_3,
| | | | | |              all_731_0, vrow1, simplifying with (7), (68) gives:
| | | | | |   (69)  all_731_0 = vrow1 & all_279_3 = vtempty
| | | | | | 
| | | | | | ALPHA: (69) implies:
| | | | | |   (70)  all_279_3 = vtempty
| | | | | | 
| | | | | | REDUCE: (18), (70) imply:
| | | | | |   (71)   ~ (0 = 0)
| | | | | | 
| | | | | | CLOSE: (71) is inconsistent.
| | | | | | 
| | | | | End of split
| | | | | 
| | | | Case 2:
| | | | | 
| | | | |   (72)   ? [v0: $int] : (all_447_0 = vtempty & vrowIn(v0, all_279_0) =
| | | | |           0 & vtcons(v0, vtempty) = all_279_2)
| | | | | 
| | | | | DELTA: instantiating (72) with fresh symbol all_731_0 gives:
| | | | |   (73)  all_447_0 = vtempty & vrowIn(all_731_0, all_279_0) = 0 &
| | | | |         vtcons(all_731_0, vtempty) = all_279_2
| | | | | 
| | | | | ALPHA: (73) implies:
| | | | |   (74)  all_447_0 = vtempty
| | | | |   (75)  vtcons(all_731_0, vtempty) = all_279_2
| | | | | 
| | | | | REDUCE: (11), (74) imply:
| | | | |   (76)   ~ (all_279_3 = vtempty)
| | | | | 
| | | | | GROUND_INST: instantiating (1) with all_279_2, vtempty, all_279_3,
| | | | |              all_731_0, vrow1, simplifying with (7), (75) gives:
| | | | |   (77)  all_731_0 = vrow1 & all_279_3 = vtempty
| | | | | 
| | | | | ALPHA: (77) implies:
| | | | |   (78)  all_279_3 = vtempty
| | | | | 
| | | | | REDUCE: (18), (78) imply:
| | | | |   (79)   ~ (0 = 0)
| | | | | 
| | | | | CLOSE: (79) is inconsistent.
| | | | | 
| | | | End of split
| | | | 
| | | Case 2:
| | | | 
| | | |   (80)  all_447_0 = all_279_2 & all_279_0 = vtempty
| | | | 
| | | | ALPHA: (80) implies:
| | | |   (81)  all_279_0 = vtempty
| | | | 
| | | | REDUCE: (8), (81) imply:
| | | |   (82)  vtcons(vrow3, all_279_1) = vtempty
| | | | 
| | | | GROUND_INST: instantiating (DIFF-tempty-tcons) with all_279_1, vrow3,
| | | |              simplifying with (82) gives:
| | | |   (83)  $false
| | | | 
| | | | CLOSE: (83) is inconsistent.
| | | | 
| | | End of split
| | | 
| | Case 2:
| | | 
| | |   (84)  all_447_0 = vtempty & all_279_2 = vtempty
| | | 
| | | ALPHA: (84) implies:
| | |   (85)  all_279_2 = vtempty
| | | 
| | | REDUCE: (7), (85) imply:
| | |   (86)  vtcons(vrow1, all_279_3) = vtempty
| | | 
| | | GROUND_INST: instantiating (DIFF-tempty-tcons) with all_279_3, vrow1,
| | |              simplifying with (86) gives:
| | |   (87)  $false
| | | 
| | | CLOSE: (87) is inconsistent.
| | | 
| | End of split
| | 
| End of split
| 
End of proof
% SZS output end Proof for theBenchmark

Loading ARI495=1.p ...
Warning: You are using the normal version of Princess to solve TPTP problems.
         Note that this version assumes a non-standard semantics
         of uninterpreted sorts, defining all domains to be infinite.
         For full support of TPTP please download the dedicated
         CASC/TPTP of Princess from
         http://www.philipp.ruemmer.org/princess.shtml#tptp
Warning: Problem contains reals, using incomplete axiomatisation
Preprocessing ...
Proving ...

VALID

